"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../..");
class EpollLoop {
    constructor(maxEvents = 64) {
        this.asyscall = () => {
        };
        this.maxEvents = maxEvents;
        this.epfd = __1.epoll_create1(0);
        if (this.epfd < 0) {
            throw new Error('Could not create epoll.');
        }
    }
    listen(fd, callback) {
        const event = {
            events: 1 /* EPOLLIN */ | 2147483648 /* EPOLLET */,
            data: [fd, 0],
        };
        return __1.epoll_ctl(this.epfd, 1 /* ADD */, fd, event);
    }
    run() {
        const evbuf = new Buffer(__1.epoll_event.size * this.maxEvents);
        const waitres = __1.epoll_wait(this.epfd, evbuf, this.maxEvents, 5000);
        if (waitres > 0) { // New events arrived.
            const event = __1.epoll_event.unpack(evbuf);
            console.log('event', event);
            if (event.events & 4 /* EPOLLOUT */) { // Socket to send data.
                console.log('EPOLLOUT', event.events & 4 /* EPOLLOUT */);
            }
            if (event.events & 1 /* EPOLLIN */) { // Socket received data.
                console.log('EPOLLIN', event.events & 1 /* EPOLLIN */);
                /*
                var buf = new Buffer(1000);
                var bytes = libjs.read(this.fd, buf);
                if (bytes < -1) {
                  this.onerror(Error(`Error reading data: ${bytes}`));
                }
                if (bytes > 0) {
                  var data = buf.toString().substr(0, bytes);
                  this.ondata(data);
                }
                */
            }
            if (event.events & 8 /* EPOLLERR */) { // Check for errors.
                console.log('EPOLLERR', event.events & 8 /* EPOLLERR */);
            }
        }
    }
}
exports.EpollLoop = EpollLoop;
